{
  "28fcbcfd-8e9f-80f3-89a1-f7eaca00e465": {
    "ko": {
      "title": "JavaScript는 웹에서 어떻게 비동기로 작동할까? (이벤트 루프와 큐 파헤치기)",
      "description": "브라우저의 메모리 및 JavaScript Engine이 어떻게 동작하는지에 대한 설명",
      "markdown": "\n## JavaScript가 비동기로 작동하는 것 처럼 보이는 이유 \n\n\n우리는 JavaScript를 기본적으로 ‘싱글 스레드’로 알고 있다. 싱글 스레드는 한 번에 하나의 작업만 처리 할 수 있다는 뜻이다. 하지만 우리가 Js코드를 작성하고 웹에서 실행을 해보면, 동시에 여러 작업을 부드럽게 처리하는 것 처럼 보인다.\n\n\n이러한 것은 JavaScript 엔진이 혼자 해내는 것이 아니라, JavaScript엔진 ( 보통 Chrome에서는 V8 ) 과 브라우저 환경(Web API), 이 둘을 연결하는 이벤트 루프가 있기 때문이다.\n\n\n아래의 그림은 Gemini에게 부탁해 HTML 형태로 나타낸 것이다. 아래의 그림을 보면서 어떻게 동작하는지 알아보자!!\n\n\n![<Gemini가 만든 브라우저의 구조>](/images/posts/28fcbcfd-8e9f-80f3-89a1-f7eaca00e465-f7bc2d6f14c7.png)\n\n\n## 1. JavaScript 엔진 (V8) 이란?\n\n\nJavaScript 엔진은 코드를 직접 실행하는 주체이다. 엔진은 크게 두 가지 주요 구성 요소로 나누어진다\n\n- Heap\n    - 객체 : {} , 배열 : [ ], 함수 처럼 동적으로 생성된 데이터가 저장되는 **메모리 저장소**이다.\n    - 참조 타입 데이터가 보관되는 넓은 공간\n- Call Stack\n    - 현재 실행 중인 코드가 호출 순서대로 쌓이는 **실행 목록** 이다.\n    - Last-In-First-Out(LIFO) 의 원칙으로 동작한다. 코드가 실행되면 스택에 쌓이고, 함수 실행이 끝나면(Return 된다면) 스택에서 제거가 된다.\n\n여기서 중요한점은 JavaScript 엔진은 단 하나의 Call Stack을 가진다는 것이다. 만약 시간이 오래 걸리는 작업이 Call Stack을 차지하고 있다면, 그 작업이 끝날 떄가지 다른 어떤 코드도 실행될 수 없다. ( 이 부분에서 우리는 JavaScript가 싱글 스레드인걸 확인할 수 있다.)\n\n\n엥? 그러면 결국에 실행이 멈추는거 아닌가요? 라고 생각을 할때쯤 아래의 브라우저 환경을 봐보자\n\n\n## 2. Browser Environment : Web APIs ( 조력자 )\n\n\n브라우저는 JavaScript 엔진이 할 수 없는 일 ( 특히 시간이 걸리거나 외부 자원이 필요한 작업들을 대신 처리해주는 강력한 기능들(Web API라 부름)을 제공한다.\n\n\n아래는 Web APIs 의 목록들이다\n\n\n### 2-1 . Web APIs \n\n- 타이머 API : setTimeout, setInterval\n- 네트워크 API : fetch, XMLHttpRequest\n- DOM 이벤트 API : addEventListener\n\n여러분들이 코드를 작성할때 자주 봤던 것들이 아닌가? 이 작업들은 JavaScript 엔진이 직접 처리하는것이 아니다! 코드가 setTimeout 같은 WebAPI를 호출하면, 엔진은 이 작업을 브라우저에게 위임하고 즉시 다음 코드로 넘어간다. 아래 예시 코드를 통해서 이해해보자.\n\n\n```javascript\nconsole.log(\"1번 출력\");\n// 타이머 API (setTimeout) 호출\nsetTimeout(function () {\n  console.log(\"2번 출력\");\n}, 1000);\n\nconsole.log(\"3번 출력\");\n\n// 실행결과\n//1번 출력\n//3번 출력\n//2번 출력\n```\n\n\n위 코드를 실행해보면 싱글 스레드인 JS에서만 실행된다면 1번 출력 ⇒ 1초 기다림 ⇒ 2번 출력 ⇒ 3번 출력이 되어야 맞지만, 2번 출력은 위에서 얘기한 타이머 API이기 때문에 브라우저에게 보내버린다! 그렇다면 브라우저는 이것을 어떻게 받을까? 브라우저에는 2개의 대기열 공간이 있다\n\n\n### 2-2. MicroTask & Task Queue : 대기열\n\n- Microtask Queue - 1순위\n    - **Promise**의 **then()**, **catch()**, **finally()** 나 **await** 키워드 이후의 코드를 대기시키는 공간이다\n    - 즉시 처리해야 하는 우선순위가 높은 공간\n<details>\n<summary>이외에 Microtask Queue로 가는 코드</summary>\n\nfetch, queueMicrotask(callback), MutationObserver 등\n\n\n</details>\n\n- Task Queue - 2순위\n    - **setTimeOut()**, **onClick()**처럼 일반적인 비동기 작업의 콜백 함수들이 대기하는 곳\n<details>\n<summary>이외에 Task Queue로 가는 코드</summary>\n\nsetInterval, addEventListener, I/O (입출력) 작업, setImmediate() 등\n\n\n</details>\n\n\n위와 같은 대기열에 작업들을 보관한다. 그런데 막연히 1순위 2순위라고 하지만 정확히 실행하는 기준이 뭘까? 그것을 관리하는것은 **EventLoop**이다 아래에서 EventLoop의 동작순서를 알아보자.\n\n\n### 3. Event Loop : 지휘자\n\n\n이벤트 루프는 아래와 같은 정해진 순서로 쉼 없이 동작한다. 순서를 한번 봐보자.\n\n1. 이벤트 루프는 Call Stack이 비어 있는지 항상 확인한다.\n2. **Call Stack이 비어있다면, Task Queue를 확인한다.**\n    - 만약 Call Stack이 비워있지 않다면 **비워질때 까지** 그저 기다린다.\n3. Task Queue에 작업이 있다면, 가장 **오래된 작업 하나**만 꺼내서 Call Stack 으로 옮겨 실행한다.\n4. Call Stack이 해당 Task를 모두 실행하고 다시 Call Stack이 완전히 비워지면, **Event Loop**는 MicroTaskQueue를 확인한다.\n5. Microtask Queue에 있는 **모든 작업을 전부(큐가 완전히 빌 때까지)** 순서대로 Call Stack으로 옮겨 실행한다.\n    - Microtask Queue가 완전히 비워졌다면, (필요시 렌더링을 수행하고) 다시 2번으로 돌아가 다음 Task를 기다린다.\n\n자, 이벤트 루프가 어떻게 동작하는지 알겠는가? 나는 처음에 이런 구조를 봤을때 어떻게 동작하는지 전혀 이해가 안갔다! 이해를 돕기위해서 아래 코드와 그림을 봐주길 바란다.\n\n\n```javascript\nconsole.log('1. console');\n\nsetTimeout(function() {\n  console.log('4. Task Queue');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('3. Microtask Queue');\n});\n\nconsole.log('2. console');\n\n// Result\n// 1. console\n// 2. console\n// 3. Microtask Queue\n// 4. Task Queue\n```\n\n\n![IMG_E981C029E234-1.jpeg](/images/posts/28fcbcfd-8e9f-80f3-89a1-f7eaca00e465-7ac17cfcf202.jpeg)\n\n\n위 그림은 대략적인 코드의 실행 흐름을 나타낸 것이다.\n\n\n자 이제 여러분들은 이제 한 가지 사실을 알게 되었다. 작성자는 그림을 엄청 못그린다는 것을!\n\n\n하지만 이게 최선이다. 나도 이해했으니 여러분들도 이해하려고 한번 노력해보자\n\n\n일단 주황색 번호는 실행의 흐름을 나타낸 번호이고, 청록색은 코드가 console에 표기되었을 시점을 이야기한다. 차례대로 위 코드를 바탕으로 설명해보겠다. ( **번호는 흐름만 나타냄! 아래 번호와 매칭 되는게 아님 !**)\n\n    1. `console.log('1. console')`가 **Call Stack**에 Push\n    2. 코드가 실행되어 콘솔에 '1. console'이 출력되고, Call Stack에서 Pop\n    3. `setTimeout(callback, 0)` 함수가 **Call Stack**에 Push\n    4. `setTimeout`이 실행되면서, Web API(Timer)에게 \"이 `callback` 함수를 0초 뒤에 **Task Queue**에 넣어줘\"라고 위임(등록)\n    5. `setTimeout` 함수 자체는 자기 할 일(위임)을 마쳤으므로 Call Stack에서 **Pop**됩니다. (0초를 기다리지 않는다.)\n    6. `Promise.resolve().then(callback)` 코드가 **Call Stack**에 Push\n    7. `.then()` 메서드가 실행되면서, Promise가 즉시 `resolve`되었기 때문에 `.then()`의 `callback` 함수를 **Microtask Queue**에 등록\n    8. `Promise...then()` 코드 자체도 Call Stack에서 **Pop**\n    9. `console.log('2. console')`가 **Call Stack**에 Push\n    10. 코드가 실행되어 콘솔에 '2. console'이 출력되고, Call Stack에서 Pop\n    11. **(이제 동기 코드가 모두 끝) JavaScript 엔진의 Call Stack이 완전히 비워짐**\n    12. **이벤트 루프**가 작동. 가장 먼저 **Microtask Queue**를 확인\n    13. Microtask Queue에 대기 중인 `Promise의 callback`을 발견하고, 이것을 **Call Stack**으로 옮긴다.\n    14. Call Stack에서 `Promise의 callback`이 실행되어 콘솔에 '3. Microtask Queue'가 출력되고, Pop\n    15. 이벤트 루프가 Microtask Queue가 비워진 것을 확인\n    16. 이벤트 루프가 **Task Queue**를 확인합니다. 0초가 지나 Web API가 넣어준 `setTimeout의 callback`을 발견하고, 이것을 **Call Stack**으로 옮긴다.\n    17. Call Stack에서 `setTimeout의 callback`이 실행되어 콘솔에 '4. Task Queue'가 출력되고, Pop됩\n    18. 모든 큐가 비워지고, 프로그램은 새로운 이벤트(클릭, 타이머 등)를 기다린다.\n\n이것이 이벤트 루프의 전체적인 흐름이다. \n\n\n싱글 스레드인 JS가 브라우저의 도움을 받아 비동기처럼 동작하는 방식에 대해서 알아보았다. **이러한 동작 원리를 이해하는 것은** '코드가 왜 이 순서로 실행되는지' 예측할 수 있게 하여 **치명적인 버그를 예방**하고, **사용자에게 부드러운 화면(끊김 없는 UI/UX)을 제공**하는 고성능 코드를 작성하는 데 **핵심적인 기반**이 된다고 생각한다.\n\n\n이글을 보는 사람이 있을진 모르지만, 도움이 됐으면 좋겠고, 틀린 부분은 언제든지 가르켜주길 환영한다.\n\n"
    },
    "en": {
      "title": "How does JavaScript work asynchronously on the web? (Digging into event loops and queues)",
      "description": "an explanation of how the browser's memory and JavaScript Engine work",
      "markdown": "\n## Why JavaScript seems to work asynchronously \n\n\nwe know JavaScript as \"single-threaded\" by default. single-threaded means that it can only handle one task at a time. but when we write Js code and run it on the web, it seems to smoothly handle multiple tasks at the same time.\n\n\nthis is because the JavaScript engine doesn't do it alone, there is a JavaScript engine (usually V8 in Chrome), the browser environment (Web API), and an event loop that connects the two.\n\n\nbelow is an illustration of this in HTML form, courtesy of Gemini. take a look and see how it works!\n\n\n![<Gemini가 만든 브라우저의 구조>](/images/posts/28fcbcfd-8e9f-80f3-89a1-f7eaca00e465-f7bc2d6f14c7.png)\n\n\n## 1. What is JavaScript Engine (V8)?\n\n\nThe JavaScript engine is the entity that directly executes the code. the engine is divided into two main components\n\n- Heap\n    - a memory store where dynamically generated data such as objects: {}, arrays: [ ], and functions are stored.\n    - a large space where reference-type data is stored\n- Call Stack\n    - a list of currently running code that is stacked in the order of its calls.\n    - It works on the principle of Last-In-First-Out (LIFO). when code is executed, it is added to the stack, and when the function finishes executing (if it returns), it is removed from the stack.\n\nthe important thing to note is that the JavaScript engine has only one call stack. if a time-consuming task is occupying the call stack, no other code can run until it finishes. (This is where we see that JavaScript is single-threaded)\n\n\nhmm, doesn't that mean it will eventually stop running? just when you're thinking, \"Hmm, doesn't that mean it will eventually stop running?\", look at the browser environment below\n\n\n## 2. Browser Environment : Web APIs ( Helper )\n\n\nbrowsers provide a powerful set of features (called Web APIs) that allow you to do things that the JavaScript engine can't do, especially things that take time or require external resources.\n\n\nbelow is a list of Web APIs\n\n\n### 2-1 . Web APIs \n\n- timer APIs: setTimeout, setInterval\n- network APIs: fetch, XMLHttpRequest\n- DOM Event API: addEventListener\n\nyou've probably seen this a lot when writing code, right? These tasks are not handled directly by the JavaScript engine! When your code calls a WebAPI like setTimeout, the engine delegates this task to the browser and immediately moves on to the next code. let's look at the example code below to understand\n\n\n```javascript\nconsole.log(\"1번 출력\");\n// 타이머 API (setTimeout) 호출\nsetTimeout(function () {\n  console.log(\"2번 출력\");\n}, 1000);\n\nconsole.log(\"3번 출력\");\n\n// 실행결과\n//1번 출력\n//3번 출력\n//2번 출력\n```\n\n\nif you run the above code, if it is executed only in JS, which is single-threaded, it should be output 1 ⇒ wait 1 second ⇒ output 2 ⇒ output 3, but output 2 is sent to the browser because it is the timer API mentioned above! So how does the browser receive it? the browser has two queue spaces\n\n\n### 2-2. MicroTask &amp; Task Queue : Queue\n\n- Microtask Queue - Priority 1\n    - this is the space to wait for code after the **then()**, **catch()**, **finally()** or **await** keyword of **Promise**\n    - high priority space that needs to be processed immediately\n<details>\n<summary>이외에 Microtask Queue로 가는 코드</summary>\n\nfetch, queueMicrotask(callback), MutationObserver 등\n\n\n</details>\n\n- Task Queue - 2nd priority\n    - where callback functions for common asynchronous tasks like **setTimeOut()**, **onClick()**, etc. wait\n<details>\n<summary>이외에 Task Queue로 가는 코드</summary>\n\nsetInterval, addEventListener, I/O (입출력) 작업, setImmediate() 등\n\n\n</details>\n\n\nwe keep tasks in the same queue as above. but what exactly is the criteria for executing the first and second priority? It is the EventLoop that manages it. Let's see how the EventLoop works below.\n\n\n### 3. Event Loop: Conductor\n\n\nthe event loop runs in a fixed order as shown below. let's take a look at the sequence.\n\n1. the event loop always checks to see if the Call Stack is empty.\n2. **If the Call Stack is empty, it checks the Task Queue\n    - if the Call Stack is not empty, it simply waits **until it is**.\n3. If there are tasks in the Task Queue, pull out the oldest task and move it to the Call Stack and run it.\n4. Once the Call Stack has executed all of its tasks and the Call Stack is completely empty again, the Event Loop checks the MicroTaskQueue.\n5. It moves all the tasks in the Microtask Queue to the Call Stack and executes them in order (until the queue is completely empty).\n    - Once the Microtask Queue is completely empty, it goes back to step 2 (rendering if necessary) and waits for the next Task.\n\nnow, do you see how the Event Loop works? I didn't understand how it worked at all when I first saw this structure! Take a look at the code and illustration below for a better understanding.\n\n\n```javascript\nconsole.log('1. console');\n\nsetTimeout(function() {\n  console.log('4. Task Queue');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('3. Microtask Queue');\n});\n\nconsole.log('2. console');\n\n// Result\n// 1. console\n// 2. console\n// 3. Microtask Queue\n// 4. Task Queue\n```\n\n\n![IMG_E981C029E234-1.jpeg](/images/posts/28fcbcfd-8e9f-80f3-89a1-f7eaca00e465-7ac17cfcf202.jpeg)\n\n\nthe figure above shows a rough flow of code execution.\n\n\nso now you know one thing. the author is terrible at drawing!\n\n\nbut it's for the best. i get it, so let's try to understand it\n\n\nfirst of all, the orange numbers are the flow of the execution, and the cyan color is when the code is displayed in the console. i'll explain each step based on the code above. (**Numbers only indicate the flow! They don't match the numbers below!**)\n\n    1. `console.log('1. console')`push to the **Call Stack\n    2. code is executed and '1. console' is printed to the console, and the Call Stack calls the Pop\n    3. `setTimeout(callback, 0)` function is executed on the **Call Stack**, Push\n    4. `setTimeout`is executed, delegating (registering) the Web API (Timer) to \"put this `callback` function into the **Task Queue** in 0 seconds\"\n    5. `setTimeout` the function itself has done its job (delegation), so it **Pops** from the Call Stack (it doesn't wait for 0 seconds)\n    6. `Promise.resolve().then(callback)` the code pushes to the Call Stack\n    7. `.then()` method to the **Call Stack**, it immediately `resolve`the `callback` function of `.then()`to the **Microtask Queue** because the Promise was immediately \n    8. `Promise...then()` the code itself also executes the **Pop** method on the Call Stack\n    9. `console.log('2. console')`in the Call Stack and the Push\n    10. code is executed, which prints '2. console' to the console, and then Pop\n    11. **(all synchronous code is now finished), the JavaScript engine's Call Stack is completely empty\n    12. the **Event Loop** is working. first and foremost, check the **Microtask Queue**\n    13. We find `Promise의 callback`waiting in the Microtask Queue, and move it to the **Call Stack**.\n    14. In the Call Stack, `Promise의 callback`is executed, which prints '3. Microtask Queue' in the console, and the Pop\n    15. event Loop confirms that the Microtask Queue is empty\n    16. the event loop checks the **Task Queue**. after 0 seconds, the Web API finds `setTimeout의 callback`and moves it to the Call Stack.\n    17. The Call Stack executes `setTimeout의 callback`, which prints '4. Task Queue' to the console, and pops\n    18. all queues are emptied, and the program waits for a new event (click, timer, etc.).\n\nthis is the overall flow of the event loop. \n\n\nwe've seen how JS, which is single-threaded, behaves asynchronously with the help of the browser. **I believe that understanding how this works is a key foundation for writing high-performance code that allows you to predict \"why your code is executing in this order\", prevent fatal bugs, and provide the user with a smooth experience (seamless UI/UX).\n\n\ni hope this helps, and I'm happy to be corrected if I'm wrong.\n\n"
    },
    "ja": {
      "title": "JavaScriptはどのようにWebで非同期で動作するのか？ (イベントループとキューを掘り下げる)",
      "description": "ブラウザのメモリとJavaScript Engineがどのように動作するかについての説明",
      "markdown": "\n## JavaScriptが非同期で動作するように見えるのはなぜ？ \n\n\nJavaScriptは基本的に「シングルスレッド」として知られています。シングルスレッドは一度に一つの作業しか処理できないという意味です。しかし、私たちがJsコードを書いてウェブ上で実行してみると、同時に複数のタスクをスムーズに処理しているように見えます。\n\n\nこれはJavaScriptエンジンが一人でやっているのではなく、JavaScriptエンジン(通常ChromeではV8)とブラウザ環境(Web API)、この二つをつなぐイベントループがあるからです。\n\n\n下の図は、Geminiに頼んでHTMLで表したものです。下の図を見ながら、どのように動作するのか見てみましょう！\n\n\n![<Gemini가 만든 브라우저의 구조>](/images/posts/28fcbcfd-8e9f-80f3-89a1-f7eaca00e465-f7bc2d6f14c7.png)\n\n\n## 1.JavaScriptエンジン（V8）とは？\n\n\nJavaScriptエンジンはコードを直接実行する主体です。エンジンは大きく2つの主要な構成要素に分けられます。\n\n- Heap\n    - オブジェクト : {} , 配列 : [ ], 関数のように動的に生成されたデータが保存される**メモリストレージ**です。\n    - 参照型データが保管される広い空間\n- Call Stack\n    - 現在実行中のコードが呼び出し順に積み上げられる**実行リスト**です。\n    - Last-In-First-Out(LIFO) の原則で動作します。コードが実行されるとスタックに蓄積され、関数の実行が終わったら(Returnされたら)スタックから削除されます。\n\nここで重要な点はJavaScriptエンジンは一つのCall Stackを持つということです。もし、時間がかかる作業がCall Stackを占有している場合、その作業が終わるまで他のコードは実行することができません。(この部分で私たちはJavaScriptがシングルスレッドであることを確認することができます).\n\n\nえ？ そうすると、最終的に実行が止まるんじゃないの？と思った時、下記のブラウザ環境を見てみましょう。\n\n\n## 2. Browser Environment : Web APIs ( 助っ人 )\n\n\nブラウザは、JavaScriptエンジンができないこと(特に、時間がかかったり、外部リソースが必要な作業を代わりに処理してくれる強力な機能(Web APIと呼ばれる)を提供します。\n\n\n以下は Web APIs のリストです。\n\n\n### 2-1 .Web APIs \n\n- タイマー API : setTimeout, setInterval\n- ネットワークAPI : fetch, XMLHttpRequest\n- DOMイベントAPI : addEventListener\n\n皆さんがコードを書いてる時よく見たことではないでしょうか？ この作業はJavaScriptエンジンが直接処理するものではありません！コードがsetTimeoutのようなWebAPIを呼び出すと、エンジンはこの作業をブラウザに委任してすぐに次のコードに移ります。下記の例題コードを見て理解しましょう。\n\n\n```javascript\nconsole.log(\"1번 출력\");\n// 타이머 API (setTimeout) 호출\nsetTimeout(function () {\n  console.log(\"2번 출력\");\n}, 1000);\n\nconsole.log(\"3번 출력\");\n\n// 실행결과\n//1번 출력\n//3번 출력\n//2번 출력\n```\n\n\n上のコードを実行してみると、シングルスレッドであるJSだけで実行する場合は1回目の出力⇒1秒待ち⇒2回目の出力⇒3回目の出力になるはずですが、2回目の出力は上記のタイマーAPIなので、ブラウザに送信してしまいます。 では、ブラウザはこれをどうやって受け取るのでしょうか？ブラウザには2つのキュースペースがある\n\n\n### 2-2. MicroTask &amp; Task Queue : 待ち行列\n\n- Microtask Queue - 1位\n    - **Promise**の**then()**、**catch()**、**finally()**や**await**キーワード以降のコードを待機させる空間です。\n    - すぐに処理しなければならない優先順位が高い空間\n<details>\n<summary>이외에 Microtask Queue로 가는 코드</summary>\n\nfetch, queueMicrotask(callback), MutationObserver 등\n\n\n</details>\n\n- Task Queue - 2順位\n    - **setTimeOut()**, **onClick()** のような一般的な非同期タスクのコールバック関数が待機する場所。\n<details>\n<summary>이외에 Task Queue로 가는 코드</summary>\n\nsetInterval, addEventListener, I/O (입출력) 작업, setImmediate() 등\n\n\n</details>\n\n\n上のようなキューにタスクを保管します。ところで、漠然と1番目と2番目と言いますが、正確に実行する基準は何なのでしょうか？ それを管理するのは**EventLoop**です。以下でEventLoopの動作順をみてみましょう。\n\n\n### 3. Event Loop : コンダクター\n\n\nイベントループは、以下のような決まった順序でノンストップで動作します。順番を見てみましょう。\n\n1. イベントループは常にCall Stackが空であることを確認します。\n2. **Call Stackが空であれば、Task Queueを確認します。\n    - もしCall Stackが空でなければ、**空になるまで**ただ待つだけです。\n3. Task Queueにタスクがある場合、最も古いタスクを1つだけ取り出し、Call Stackに移動して実行します。\n4. Call Stackが全てのタスクを実行し、Call Stackが完全に空になったら、**Event Loop**はMicroTaskQueueを確認します。\n5. Microtask Queueにある**全てのタスクを全て(キューが完全に空になるまで)**順番にCall Stackに移して実行します。\n    - Microtask Queueが完全に空になったら、(必要に応じてレンダリングを行い)再び2番に戻り、次のTaskを待ちます。\n\nさて、イベントループがどのように動作するのか分かりますか？ 私は最初にこのような構造を見た時、どのように動作するのか全く理解できませんでした！理解を助けるために、以下のコードと図を見てください。\n\n\n```javascript\nconsole.log('1. console');\n\nsetTimeout(function() {\n  console.log('4. Task Queue');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('3. Microtask Queue');\n});\n\nconsole.log('2. console');\n\n// Result\n// 1. console\n// 2. console\n// 3. Microtask Queue\n// 4. Task Queue\n```\n\n\n![IMG_E981C029E234-1.jpeg](/images/posts/28fcbcfd-8e9f-80f3-89a1-f7eaca00e465-7ac17cfcf202.jpeg)\n\n\n上の図は、おおよそのコードの実行フローを示したものです。\n\n\nさて、これで皆さんは1つの事実が分かりました。作者は絵がめちゃくちゃ下手だということ！\n\n\nでも、これがベストだ。私も理解したから、皆さんも理解しようと頑張りましょう。\n\n\nまず、オレンジ色の番号は実行の流れを表した番号で、青緑色はコードがconsoleに表記された時点を表しています。順番に上のコードをもとに説明します。 ( **番号は流れだけを表します！下の番号とマッチするわけではありません!!!)\n\n    1.`console.log('1. console')`が**Call Stack**へPush\n    2. コードが実行されてコンソールに'1.console'が出力され、Call StackでPop\n    3. `setTimeout(callback, 0)` 関数が**Call Stack**にPush\n    4.`setTimeout`が実行され、Web API(Timer)に\"この`callback` 関数を0秒後に**Task Queue**に入れてくれ\"と委任(登録)します。\n    5. `setTimeout` 関数自体は自分の仕事(委任)を終えたので、Call Stackで**Pop**されます。 (0秒を待たない)。\n    6. `Promise.resolve().then(callback)` コードが**Call Stack**にPush\n    7. `.then()` メソッドが実行され、Promiseがすぐに`resolve`になったので`.then()`の`callback` 関数を**Microtask Queue**に登録します。\n    8. `Promise...then()` コード自体もCall Stackで**Pop**が**Call Stack**にPush**されます。\n    9.`console.log('2. console')`が**Call Stack**へPush\n    10. コードが実行されてコンソールに'2.console'が出力され、Call StackからPop\n    11. **(これで同期コードが全て終了)JavaScriptエンジンのCall Stackが完全に空になります。\n    12. **イベントループ**が動作。最初に**Microtask Queue**を確認します。\n    13. Microtask Queueに待機している`Promise의 callback`を見つけ、これを**Call Stack**に移動します。\n    14. Call Stackで`Promise의 callback`が実行され、コンソールに'3.Microtask Queue'が出力され、Pop\n    15. イベントループがMicrotask Queueが空になったことを確認します。\n    16. イベントループが**Task Queue**を確認します。0秒後、Web APIが入れてくれた`setTimeout의 callback`を見つけ、これを**Call Stack**に移動します。\n    17. Call Stackで`setTimeout의 callback`が実行され、コンソールに'4.Task Queue'が出力され、Popされます。\n    18. すべてのキューが空になり、プログラムは新しいイベント(クリック、タイマーなど)を待ちます。\n\nこれがイベントループの全体的な流れです。 \n\n\nシングルスレッドであるJSがブラウザの助けを借りて非同期のように動作する方法について説明しました。 **このような動作原理を理解することは、'コードがなぜこの順番で実行されるのか'を予測できるようになり、'致命的なバグを予防'し、'ユーザーにスムーズな画面(途切れのないUI/UX)を提供'する高性能コードを作成するための'核心的な基盤'になると思います。\n\n\nこのイーグルを見ている人がいるかもしれないが、役に立つといいし、間違った部分はいつでも指摘してくれることを歓迎する。\n\n"
    }
  },
  "298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062": {
    "ko": {
      "title": "브라우저의 렌더링 과정(Critical Rendering Path)",
      "description": "",
      "markdown": "\n이 페이지는 공부를 위해 개인이 기록한 것이므로, 언제든지 내용이 변하거나 수정될 수 있으며, 부정확한 내용이 있을 수도있습니다.\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-1169a013222e.png)\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-df37cd003acf.png)\n\n\nDOM 및 CSSOM 은 브라우저가 더 이해하기 쉽게 변형한 모델\n\n\nrender Tree는 웹페이지의 청사진\n\n\nlayout : 요소의 배치를 잡는 작업\n\n\nPainting : 실제로 화면에 그려내는 작업\n\n\n화면의 업데이트는 JS가 DOM을 수정하면 발생\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-b42359f3941f.png)\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-6962c2c4f0d3.png)\n\n"
    },
    "en": {
      "title": "critical Rendering Path in the Browser",
      "description": "",
      "markdown": "\nthis page was written by an individual for his/her own study, so the content is subject to change or modification at any time and may contain inaccuracies.\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-1169a013222e.png)\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-df37cd003acf.png)\n\n\nDOM and CSSOM are variations of the model that browsers make easier to understand\n\n\nthe render tree is the blueprint of a webpage\n\n\nlayout: the placement of the elements\n\n\nPainting: Actually drawing on the screen\n\n\nupdates to the screen occur when JS modifies the DOM, which happens when the\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-b42359f3941f.png)\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-6962c2c4f0d3.png)\n\n"
    },
    "ja": {
      "title": "ブラウザのレンダリング過程(Critical Rendering Path)",
      "description": "",
      "markdown": "\nこのページは勉強のために個人が記録したものですので、いつでも内容が変更・修正される可能性があり、不正確な内容が含まれている可能性があります。\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-1169a013222e.png)\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-df37cd003acf.png)\n\n\nDOM と CSSOM は、ブラウザがより理解しやすく変形したモデルです。\n\n\nrender Treeはウェブページの青写真\n\n\nlayout : 要素の配置を決める作業\n\n\nPainting : 実際に画面に描画する作業\n\n\n画面の更新は、JSがDOMを修正すると発生します。\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-b42359f3941f.png)\n\n\n![image.png](/images/posts/298cbcfd-8e9f-80b2-82e3-f9dc1d0f4062-6962c2c4f0d3.png)\n\n"
    }
  }
}